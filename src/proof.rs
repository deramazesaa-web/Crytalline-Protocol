// src/proof.rs

use crate::deontic_engine::Rule;
use crate::axiomatics::AxiomaticState;

#[derive(Debug, Clone)]
pub struct AxiomaticProof {
    pub rule_id: u32,
    pub state_commitment: String,
    pub witness_hash: String,
    pub verified: bool,
}

pub struct ProofGenerator;

impl ProofGenerator {
    /// Generates a proof that a rule was correctly committed to the state
    pub fn generate_proof(rule: &Rule, state: &AxiomaticState) -> AxiomaticProof {
        println!("[PROOF] Generating mathematical witness for Rule #{}...", rule.id);
        
        // Simulating a cryptographic binding between the rule and the current state root
        let combined_data = format!("{}-{}-{}", rule.id, rule.priority, state.state_root);
        let simulated_witness = format!("witness-0x{:x}", combined_data.len() * 777);

        AxiomaticProof {
            rule_id: rule.id,
            state_commitment: state.state_root.clone(),
            witness_hash: simulated_witness,
            verified: true, // Mark as initially generated
        }
    }

    /// Validates an existing proof against the current axiomatic state
    pub fn verify_proof(proof: &AxiomaticProof, state: &AxiomaticState) -> bool {
        println!("[VERIFIER] Checking witness integrity for Rule #{}...", proof.rule_id);
        
        // A proof is valid if its state commitment matches the system's current root
        // and it was generated by the trusted generator logic.
        proof.state_commitment == state.state_root && proof.verified
    }
}
